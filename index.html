<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;feng-t.github.io&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://feng-t.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-线程-三" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/18/%E7%BA%BF%E7%A8%8B-%E4%B8%89/" class="article-date">
  <time datetime="2019-12-18T08:26:47.990Z" itemprop="datePublished">2019-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/18/%E7%BA%BF%E7%A8%8B-%E4%B8%89/">线程-三</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>在JDK1.5的版本中新加入了很多特性。其中就有<code>ReentrantLock</code>。<code>ReentrantLock</code>比<code>synchronized</code>更灵活。功能也更强大。学习线程的过程中也是不可避免的。<br><code>new</code> 一个<code>ReentrantLock</code> 返回一个<code>Lock</code>接口对象。<br>通过<code>lock</code>加锁。<code>unlock</code>解锁。在lock与unlock之间的代码就是同步区域。</p>
<h5 id="使用Condition实现等待-通知"><a href="#使用Condition实现等待-通知" class="headerlink" title="使用Condition实现等待/通知"></a>使用Condition实现等待/通知</h5><p>关键字<code>synchronized</code>与<code>wait</code>和<code>notify</code>方法相结合可以实现等待通知模式，类<code>ReentrantLock</code>也可以实现同样的功能，但是要借助于<code>Condition</code>对象，它有更好的灵活性，比如实现多路通知功能，也就是说在一个lock对象创建多个<code>Condition</code>实例，线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择的进行线程通知，在调度线程上更灵活。<br>在notify中，被通知的线程是JVM随机选择的。但使用<code>ReentrantLock</code>结合<code>Condition</code>可以实现选择性通知。<br><strong>代码如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCondition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Service service = <span class="keyword">new</span> Service();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            service.await();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        service.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"解锁"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Condition</code>的<code>await</code>等于<code>Object</code>的<code>wait</code>，<code>signal</code>等于<code>notify</code>。<br><code>signalAll</code>等于<code>notifyAll</code>。</p>
<h5 id="使用Condition实现选择性通知。"><a href="#使用Condition实现选择性通知。" class="headerlink" title="使用Condition实现选择性通知。"></a>使用Condition实现选择性通知。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadConditionSelect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadConditionSelectService service1 = <span class="keyword">new</span> ThreadConditionSelectService();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            service1.awaitA();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            service1.awaitB();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        service1.signalAll_A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadConditionSelectService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionA = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionB = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"A:wait"</span>);</span><br><span class="line">            conditionA.await();</span><br><span class="line">            System.out.println(<span class="string">"A:run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"B:wait"</span>);</span><br><span class="line">            conditionB.await();</span><br><span class="line">            System.out.println(<span class="string">"B:run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalAll_A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"A:signalAll"</span>);</span><br><span class="line">            conditionA.signalAll();</span><br><span class="line">            System.out.println(<span class="string">"A:signalAll"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalAll_B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"B:signalAll"</span>);</span><br><span class="line">            conditionB.signalAll();</span><br><span class="line">            System.out.println(<span class="string">"B:signalAll"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这代码中最终只有A被唤醒。<br>通过这种方式我们可以唤醒指定种类的线程。</p>
<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>锁lock分为公平锁与非公平锁。公平锁表示线程获取锁的顺序是安装线程加锁的顺序来分配的，即FIFO先进先出的顺序。而非公平锁则是抢占。随机获取锁。所以可能会有一些线程一直拿不到锁。<br> 通过创建ReentrantLock的构造函数，传入Boolean值设置锁的类型。<br> <img src="evernotecid://C1ED3B83-9B1B-4BCB-A585-72C416AE6E7A/appyinxiangcom/18133246/ENResource/p46" alt="bd0c3c3058122d3cde548384342f72e6.png"><br> 通过源码，我们可以知道，在不传入值的情况下默认是非公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGPLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadGPLockService gpLockService = <span class="keyword">new</span> ThreadGPLockService();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + <span class="string">":运行了"</span>);</span><br><span class="line">                gpLockService.await();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadGPLockService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">        lock.lock();</span><br><span class="line">  System.out.println(Thread.currentThread().getName() + <span class="string">":获得锁"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结果我们可以看出，当锁是公平锁时，谁先等待那么谁就先获取到锁。而非公平锁则是相互竞争。</p>
<h5 id="ReentrantLock类的方法"><a href="#ReentrantLock类的方法" class="headerlink" title="ReentrantLock类的方法"></a>ReentrantLock类的方法</h5><p><code>getHoldCount()</code>的作用时查询当前线程锁保持锁定的个数。也就是调用lock()方法的次数。<br><code>getQueueLength()</code>是返回正在等待获取锁的线程数，表示没有调用await的线程。<br><code>getWaitQueueLength()</code>与<code>getQueueLength()</code>相反，它表示已经调用了await方法的线程数。<br><code>hasQueuedThread(Thread)</code>的作用是查询指定线程释放在等待获取此锁定。<br><code>HasQueuedThreads()</code>的作用是查询是否有线程正在等待获取此锁定。<br><code>hasWaiters(Condition condition)</code>查询是否有线程正在等待与此锁定有关的condition条件。<br>…</p>
<h5 id="lock接口中的方法。"><a href="#lock接口中的方法。" class="headerlink" title="lock接口中的方法。"></a>lock接口中的方法。</h5><p><code>lockInterruptibly()</code>的作用是如果当前线程未被中断，则获取锁定。如果已经被中断则出现异常0</p>
<p><code>tryLock()</code>的作用是如果锁没被其他线程获取就获得锁。</p>
<p><code>tryLock(long time, TimeUnit unit)</code>在给定时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。</p>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p><code>ReentrantLock</code>类具有完全排他的效果，在同一时间下只有一个线程在执行lock方法后面的任务，虽然保证了安全性，但是效率相对低下。我们可以使用<code>ReentrantReadWriteLock</code>读写锁，在某些不需要操作实例变量中，完全可以使用读写锁来提升代码运行效率。<br>读写锁有两个锁，一个是读相关的锁，叫做共享锁，另一个是写操作相关的锁，也称排他锁。写锁与任何锁都互斥。<br>同一个时刻读锁允许多个线程获取锁，而写锁只允许一个线程获取锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service service = <span class="keyword">new</span> Service();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                service.read();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ReentrantReadWriteLock lock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(<span class="string">"获取读锁："</span>+Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获取读锁：Thread-0</span><br><span class="line">获取读锁：Thread-3</span><br><span class="line">获取读锁：Thread-5</span><br><span class="line">获取读锁：Thread-2</span><br><span class="line">获取读锁：Thread-1</span><br><span class="line">获取读锁：Thread-6</span><br><span class="line">获取读锁：Thread-4</span><br><span class="line">获取读锁：Thread-8</span><br><span class="line">获取读锁：Thread-7</span><br><span class="line">获取读锁：Thread-9</span><br></pre></td></tr></table></figure>
<p>通过lock.readLock().lock()加一个读锁。<br>通过lock.writeLock().lock()加一个写锁<br>如果这个锁是一个ReentrantLock锁，则同一时刻只能允许一个线程运行，所以如果有10个线程。每个线程睡眠0.5秒，十个线程则需要睡5秒。在使用读锁之后，所有线程都可以同时运行。<br>可见效率要高很多。<br>写线程与ReentrantLock基本上一致。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://feng-t.github.io/2019/12/18/%E7%BA%BF%E7%A8%8B-%E4%B8%89/" data-id="ck4b1a6uo00016lbkbfncfxay" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-线程-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/17/%E7%BA%BF%E7%A8%8B-%E4%BA%8C/" class="article-date">
  <time datetime="2019-12-17T06:46:52.194Z" itemprop="datePublished">2019-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/17/%E7%BA%BF%E7%A8%8B-%E4%BA%8C/">线程-二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><p>在前面线程方法中我们遇到了wait();notify();方法。接下来我们讲讲这些方法。</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><p><code>wait</code>方法的作用是将当前执行代码的线程进行等待。但<code>wait</code>并不是<code>Thread</code>的方法而是<code>Object</code>的方法。至于为什么不放在<code>Thread</code>请看这里<a href="http://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&amp;mid=2247487095&amp;idx=2&amp;sn=f3645421c165a4980d10fff2b7ce04aa&amp;chksm=96cd4e3ba1bac72d48cb685fa9a972a27047c1db5e93d7459c3c5fb2193a332b0142a21dfefd&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1566982841356&amp;sharer_shareid=91fce93925910d51fc241122334669e9#rd" target="_blank" rel="noopener">为什么wait方法定义在Object，而不是Thread</a>。这篇文章讲的很清楚了。<br><code>wait</code>方法是将当前线程放入“预执行队列”中。并且在<code>wait</code>所在的代码处停止执行。直到接到通知或中断为止。同时需要注意。在调用<code>wait</code>方法之前。线程需要获得该对象的对象对象级别锁。如果调用<code>wait</code>时没有获取到锁则抛出异常。</p>
<h5 id="wait-long"><a href="#wait-long" class="headerlink" title="wait(long)"></a>wait(long)</h5><p>带参数的方法表示超过这个时间就会自动唤醒。也就是等待多久。</p>
<h5 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h5><p><code>notify()</code>;方法恰好与<code>wait</code>相对。当线程使用<code>wait</code>方法等待时可以使用<code>notify()</code>将其唤醒。同理<code>notify</code>也需要在同步方法或同步代码块中调用。<br><code>notifyAll()</code>与<code>notify()</code>的功能一样。只不过<code>notify()</code>是唤醒一个线程。而<code>notifyAll()</code>是唤醒所有线程。(针对同一个对象的所有线程)。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread1 t1 = <span class="keyword">new</span> Thread1(o);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(<span class="string">"开始解锁"</span>);</span><br><span class="line">            o.notifyAll();</span><br><span class="line">            System.out.println(<span class="string">"结束解锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line">    Thread1(Object lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"wait开始"</span>);</span><br><span class="line">                lock.wait();</span><br><span class="line">                System.out.println(<span class="string">"wait结束:"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在线程run之后进入等待。同时主线程休眠0.5秒。0.5秒之后调用<code>notify</code>唤醒线程。所以在调用wait方法之后<code>wait</code>后面的代码就会停止执行。直到<code>notify</code>执行完毕。当唤醒之后<code>wai</code>t后面的代码继续执行<br><strong>线程之间的状态切换</strong><br>每个对象都有两个队列。一个是阻塞队列，另一个是就绪队列。当线程被唤醒之后会进入就绪队列。反之则进入阻塞队列。</p>
<h5 id="wait-notify-锁"><a href="#wait-notify-锁" class="headerlink" title="wait()/notify()/锁"></a>wait()/notify()/锁</h5><p>当<code>wait</code>执行完后。锁会自动释放。但是执行完<code>notify</code>却不会自动释放锁。从之前的代码中我们知道。代码运行到<code>wait</code>的时候会进行等待。所以<code>wait</code>后面的代码就不执行了。刚开始的时候我以为代码停在这了。所以锁也没释放。其实当<code>wait</code>运行完之后锁就会自动释放。将上面的代码稍加改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread1 t1 = <span class="keyword">new</span> Thread1(o);</span><br><span class="line">        Thread1 t2 = <span class="keyword">new</span> Thread1(o);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(<span class="string">"开始解锁"</span>);</span><br><span class="line">            o.notifyAll();</span><br><span class="line">            System.out.println(<span class="string">"结束解锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line">    Thread1(Object lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"wait开始"</span>);</span><br><span class="line">                lock.wait();</span><br><span class="line">                System.out.println(<span class="string">"wait结束:"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行的结果表明，在调用<code>wait</code>之后锁就已经被释放掉了。所有线程都要等待<code>notify</code>的同步代码块执行完毕才会继续执行</p>
<h4 id="生产者-消费者模式实现"><a href="#生产者-消费者模式实现" class="headerlink" title="生产者/消费者模式实现"></a>生产者/消费者模式实现</h4><p>等待/通知最经典的案例就是“生产者/消费者”模式。</p>
<h5 id="一生产与一消费"><a href="#一生产与一消费" class="headerlink" title="一生产与一消费"></a>一生产与一消费</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lock;</span><br><span class="line"></span><br><span class="line">    P(String lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">""</span>.equals(ThreadTestCP.value)) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                ThreadTestCP.value = System.currentTimeMillis() + <span class="string">""</span>;</span><br><span class="line">                System.out.println(<span class="string">"生产者："</span> + ThreadTestCP.value);</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lock;</span><br><span class="line"></span><br><span class="line">    C(String lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">""</span>.equals(ThreadTestCP.value)) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"消费者："</span> + ThreadTestCP.value);</span><br><span class="line">                ThreadTestCP.value = <span class="string">""</span>;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTestCP</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String lock=<span class="string">"aaa"</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            P p = <span class="keyword">new</span> P(lock);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                p.setValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            C p = <span class="keyword">new</span> C(lock);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                p.setValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次生产者生产完成之后唤醒等待线程。然后消费者进行消费。在这里如果出现多个消费者或多个生产者。那么线程就有可能出现假死状态。也就是所有线程都处于等待状态。可以将<code>notify</code>换成<code>notifyAll</code>解决假死状态。<br>同时这里的<code>notify</code>是没有区分生产者/消费者的。也就是说生产者唤醒的也有可能是生产者。<br><strong>简单来说就是</strong>：<br>消费者查看是否有数据。如果没有就等待。如果有就消费，随后唤醒生产者进行生产。<br>生产者被唤醒之后进行生产。生产之后唤醒消费者。数据载体可以是任何对象。只要生产者和消费者的数据载体是同一对象。</p>
<h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><p><strong>题目要求：</strong> 创建二十个线程。线程分为两种，一种输出“★“，另一种输出”☆“ 两种线程交替运行。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadReplaceRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       Tools tools = <span class="keyword">new</span> Tools();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               tools.MethodA();</span><br><span class="line">           &#125;).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">               tools.MethodB();</span><br><span class="line">           &#125;).start();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"★\t"</span>);</span><br><span class="line">                flag = !flag;</span><br><span class="line">                notify();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"☆\t"</span>);</span><br><span class="line">                flag = !flag;</span><br><span class="line">                notify();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个Boolean变量使两个线程变成互斥运行。使其其中一个线程进入睡眠。</p>
<h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p>很多时候主线程创建并启动子线程，如果子线程中有很多耗时的操作。往往主线程比子线程更早结束。如果在主线程中需要使用到子线程中的数据，这个时候就需要<code>join</code>方法了。<br>join方法是使所属线程正常运行run方法。当前线程无限制等待。直到所属线程销毁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadReplaceRun</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs)</span>  </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">"主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行过程中，子线程会休眠一段时间，在休眠完成之后主线程开始执行。其实join方法的底层也只是使用了wait方法；只是更方便我们使用。<br><strong>注意</strong> join方法不能与interrupt方法一起使用。</p>
<h5 id="join-long-与sleep-long-的区别"><a href="#join-long-与sleep-long-的区别" class="headerlink" title="join(long)与sleep(long)的区别"></a>join(long)与sleep(long)的区别</h5><p>这两者在运行的效果上基本没什么区别。只是咋对待同步的处理上有点区别。由于join底层是使用wait进行等待的，所以具有释放锁的特点。</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>在前面我们都是使用的<code>public static</code> 变量的形式。所有线程都使用同一个<code>public static</code>变量。<br>而<code>ThreadLocal</code>则是为每一个线程提供共享变量的功能。<br><code>ThreadLocal</code>可以被视为给线程存放数据的<code>箱子</code>。</p>
<h5 id="ThreadLocal线程隔离"><a href="#ThreadLocal线程隔离" class="headerlink" title="ThreadLocal线程隔离"></a>ThreadLocal线程隔离</h5><p>我们可以使用一个ThreadLocal类为每一个线程存入数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinAndSleep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal tl = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                tl.set(Thread.currentThread().getName() + <span class="string">""</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+tl.get());</span><br><span class="line">            &#125;);</span><br><span class="line">            t.setName(<span class="string">""</span> + i);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+tl.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难发现，每个线程get的都只是那个线程存入的数据。不能获取其他线程的数据。</p>
<h6 id="get为null"><a href="#get为null" class="headerlink" title="get为null"></a>get为null</h6><p>在没有进行set之前任何一个线程get返回的都是null。如果想设置一个默认值。我们可以继承ThreadLocal，并实现<code>inittialValue()</code>方法返回默认值</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://feng-t.github.io/2019/12/17/%E7%BA%BF%E7%A8%8B-%E4%BA%8C/" data-id="ck4b1a6uq00036lbk2j46e71t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-线程-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/05/%E7%BA%BF%E7%A8%8B-%E4%B8%80/" class="article-date">
  <time datetime="2019-12-05T12:23:15.000Z" itemprop="datePublished">2019-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/05/%E7%BA%BF%E7%A8%8B-%E4%B8%80/">线程(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>线程的状态又分为五种:</p>
<ul>
<li>New：新建状态</li>
<li>Runnable：就绪状态</li>
<li>Running：运行状态</li>
<li>Blocked：阻塞状态</li>
<li>Dead：死亡状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">New --&gt; Runnable</span><br><span class="line">Runnable--&gt;Running</span><br><span class="line">Blocked--&gt;Runnable</span><br><span class="line">Running--&gt;Runnable</span><br><span class="line">Running--&gt;Blocked</span><br><span class="line">Running--&gt;Dead</span><br></pre></td></tr></table></figure>

<h4 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h4><h5 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h5><p>判断当前线程是否是中断、停止状态，执行后将状态标志清除为<code>false</code>，静态方法。可以直接调用</p>
<h5 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h5><p>判断当前线程是否是中断、停止状态。但不清除状态标志。非静态方法。</p>
<h5 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h5><p>将状态标记为中断，用于线程退出。在<code>run</code>方法中使用<code>interrupted</code>判断线程状态。如果返回<code>true</code>则<code>return</code>或抛出异常。</p>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h5><p>将Running状态转变为Runnable状态。把线程CPU让给其他线程，让出时间不确定，有可能上一秒让出下一秒又获取到。</p>
<h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h5><p>使线程休眠多少毫秒，参数为<code>long</code> ms</p>
<h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><p>join方法的作用是父线程等待子线程执行完成后再执行。换句话说就是将异步执行的线程合并为同步的线程。</p>
<h4 id="wait-notify-notifyAll方法"><a href="#wait-notify-notifyAll方法" class="headerlink" title="wait/notify/notifyAll方法"></a>wait/notify/notifyAll方法</h4><p>这些方法并不是Thread类中的。而是Object类的方法。不过这些也是学习线程中不可或缺的。</p>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h5><p><code>wait()</code>方法的作用是将当前运行的线程挂起（即让其进入阻塞状态），直到notify或notifyAll方法来唤醒线程。此方法需要与锁一起使用。</p>
<h5 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h5><p>与使用<code>wait</code>的同一对象使用该方法即可唤醒处于等待的线程。</p>
<h5 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h5><p>与<code>notify</code>方法差不多，只不过<code>notify</code>只唤醒当前线程。而<code>notifyAll</code>则唤醒所有线程。</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>在线程中可以通过<code>setPriority(int)</code> 来设置线程优先级。子类的优先级与父类的优先级一致。<br>线程优先级从低到高为1~10。超过则抛出<code>IllegalArgumentException()</code>异常<br>且线程优先级不代表一定会按照顺序执行。</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>在Java线程中有两种线程，一种是用户线程，另一种是守护线程。<br>一旦用户线程全都执行完毕之后，守护线程也会结束。没有用户线程时守护进程将自动销毁。<br>线程可以在执行<code>start()</code>方法之前执行<code>setDaemon(true)</code> 变成守护进程。</p>
<h3 id="对象及变量并发访问"><a href="#对象及变量并发访问" class="headerlink" title="对象及变量并发访问"></a>对象及变量并发访问</h3><p>当多个线程对一个对象实例或者一个对象实例变量访问的时候就有可能出现线程安全。</p>
<h4 id="方法内的变量为线程安全"><a href="#方法内的变量为线程安全" class="headerlink" title="方法内的变量为线程安全"></a>方法内的变量为线程安全</h4><p>所有线程内部的私有变量都不会引起线程安全</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p><code>synchronized</code>所声明的方法为线程安全。<br><code>synchronized</code> 使用：<br><code>synchronized</code>可以在方法签名中声明。也可以声明代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mothed</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(Obj)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好不要使用String，或其他基本数据类型作为<code>synchronized</code>所修饰的对象。因为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a1=<span class="string">"aa"</span>;</span><br><span class="line">String a2=<span class="string">"aa"</span>;</span><br></pre></td></tr></table></figure>
<p>由于常量池的原因。a1=a2。所以在<code>synchronized(String)</code>中会被当成同一个对象。<br>使用<code>synchronized</code>之后，异步方法会进行排队。可以看作原子级的方法。<br>只有共享变量/实例才需要同步。如果不是共享变量或实例则不需要同步。</p>
<h5 id="synchronized-重入"><a href="#synchronized-重入" class="headerlink" title="synchronized 重入"></a>synchronized 重入</h5><p>对<code>synchronized</code>声明的代码块，方法来说都具有重入的特性，也就是说<code>synchronized</code>代码块或方法可以调用同一个对象的<code>synchronized</code>而不会产生死锁。</p>
<h5 id="synchronized-同步代码块"><a href="#synchronized-同步代码块" class="headerlink" title="synchronized 同步代码块"></a>synchronized 同步代码块</h5><p>使用<code>synchronized</code>声明一个同步代码块比直接声明一个方法性能要好很多。同时使用一个对象实例比<code>this</code>效率要高一些。使用<code>synchronized(非this)</code>代码块中的程序与其他同步方法是异步的。因为他锁的对象不是this，如果需要同步的话需要锁住的对象是同一个。<br><strong>注意</strong>：同步代码块放在非同步synchronized方法中进行声明，并不能保证调用方法的线程的执行顺序。所以非常容易产生“脏读”的问题。<br>也就是说<code>synchronized</code>修饰方法时，锁住的对象是<code>this</code>。所以<code>synchronized</code>修饰的方法与<code>synchronized(非this)</code>的代码块之间非常容易出问题。</p>
<h5 id="synchronized静态同步"><a href="#synchronized静态同步" class="headerlink" title="synchronized静态同步"></a>synchronized静态同步</h5><p><code>synchronized</code>可以用到静态方法上，这样写是对当前*.java文件对应的Class类进行加锁。<code>synchronized</code>加到静态方法上是对Class加锁。<code>synchronized</code>加到非静态方法上是给对象加锁。如果有一个静态方法。同时有两个实例调用此方法。则该方法为同步方法。<br><code>synchronized(Object.class)</code>等于<code>synchronized</code>声明静态方法。</p>
<h5 id="锁对象改变"><a href="#锁对象改变" class="headerlink" title="锁对象改变"></a>锁对象改变</h5><p>在同步代码块中如果锁对象发生了改变，会发生什么呢？锁对象还有用吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test1 test1 = <span class="keyword">new</span> Test1();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test1.ts(Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test1.ts(Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lock = <span class="string">"a1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ts</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">":start"</span>);</span><br><span class="line">            lock = <span class="string">"a2"</span>;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(name + <span class="string">":end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真实情况是：一旦锁发生了改变，且在改变之后又有新的线程进来。那么这两个线程的锁对象就不相等。就会变成异步方法。同时可能会产生“脏读”的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A1:start</span><br><span class="line">A2:start</span><br><span class="line">A1:end</span><br><span class="line">A2:end</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong> 只要对象不变。就算对象的属性变了，运行的结果也是同步。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p><code>volatile</code>是为了确保公共堆栈中的变量与线程私有栈中的变量保持一致。使用了<code>volatile</code>之后会从公共堆栈取值。<br><strong>如图所示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        volatileTest test = <span class="keyword">new</span> volatileTest();</span><br><span class="line">        test.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        test.setFlag(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volatileTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入run"</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"退出run：count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程没有及时读到最新的值。那么就可能会出现死循环。</p>
<p>他会一直卡在<code>while</code>循环中。因为在公共堆栈中已经修改了flag的值。但是在线程私有栈中却没有更新<code>flag</code>的值<br>加了<code>volatile</code>之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        volatileTest test = <span class="keyword">new</span> volatileTest();</span><br><span class="line">        test.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        test.setFlag(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volatileTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入run"</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"退出run：count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入run</span><br><span class="line">退出run：count = <span class="number">744998007</span></span><br></pre></td></tr></table></figure>
<h5 id="volatile与synchronized"><a href="#volatile与synchronized" class="headerlink" title="volatile与synchronized"></a>volatile与synchronized</h5><p> 乍一看volatile似乎可以解决多线程下的“脏读”问题了。但是其实上并不是。</p>
<ul>
<li><code>volatile</code>是线程同步的轻量级实现。所以<code>volatile</code>的性能比<code>synchronized</code>要好。但是随着JDK版本的提升。<code>synchronized</code>效率也的到了加强。</li>
<li>多线程访问<code>volatile</code>不会发生阻塞。<code>synchronized</code>会发生阻塞。</li>
<li><code>volatile</code>能保证数据可见性。但是不能保证原子性。而<code>synchronized</code>可以保证原子性。也可以间接保证可见性。因为他会将私有内存与公共内存中的数据做同步。</li>
<li><code>volatile</code>解决的是变量在多个线程中的可见性。而<code>synchronized</code>解决的是多个线程之间访问资源的同步性。</li>
<li>线程安全包含原子性和可见性两个方面。Java的同步机制都是围绕这两个方面来确保线程安全的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">new</span> volaitleTest().start();        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volaitleTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count; </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">             count++;   </span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"count:"</span> + count);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有的结果中都没有<code>count=10000</code>的这条结果。这个问题是因为<code>count++</code>并不是一个原子性操作。<br><strong>解决：</strong> 有一点需要注意。也就是<code>count</code>是<code>static</code>所修饰的。而且在<code>main</code>方法中是<code>new</code>了100个线程。所以我们在使用<code>synchronized</code>的时候锁对象一定是一个<code>Class</code>；<br>如将<code>synchronized</code>添加到static方法中。或者<code>synchronized</code>代码块中的锁对象是一个当前类的<code>Class</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> volaitleTest().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volaitleTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (volaitleTest.class) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"count:"</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出虽然顺序是随机的。但是一定有一条数据是count等于10000；<br><strong>方案二</strong> 使用原子类<br>在前面我们使用了<code>synchronized</code>，这次我们不用<code>synchronized</code>而使用原子类。<br>原子类可以将i++这样的操作当成一个原子操作。而不使用锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> volaitleTest().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volaitleTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (volaitleTest.class) &#123;</span><br><span class="line">                count.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"count:"</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最终结果也有10000。针对与i++这样的操作可以使用原子类来做到线程安全。<br><strong>还有个问题</strong> 虽然最终的结果已经是10000了，但是他不是顺序的。这是因为方法与方法之间不是同步的。将代码稍微改一下：将输出语句添加到同步块中，这样结果就是顺序的了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://feng-t.github.io/2019/12/05/%E7%BA%BF%E7%A8%8B-%E4%B8%80/" data-id="ck4b1a6up00026lbkh3eq6c0d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用一个变量表示多种状态" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/17/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E8%A1%A8%E7%A4%BA%E5%A4%9A%E7%A7%8D%E7%8A%B6%E6%80%81/" class="article-date">
  <time datetime="2019-10-16T16:37:30.000Z" itemprop="datePublished">2019-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/17/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E8%A1%A8%E7%A4%BA%E5%A4%9A%E7%A7%8D%E7%8A%B6%E6%80%81/">使用一个变量表示多种状态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="枚举与多状态"><a href="#枚举与多状态" class="headerlink" title="枚举与多状态"></a>枚举与多状态</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们通常会使用一个枚举表示状态，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum State&#123;</span><br><span class="line">A,</span><br><span class="line">B,</span><br><span class="line">C,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以声明一个枚举变量表示一个状态<br><strong>但是：</strong> 如果我要表示多个状态怎么办。这种方式只能解决一个状态的问题。</p>
<h3 id="二进制的位运算"><a href="#二进制的位运算" class="headerlink" title="二进制的位运算"></a>二进制的位运算</h3><p>枚举的多个状态可以通过二进制的位运算来实现。<br><strong>原理是什么</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state=<span class="number">0</span>;<span class="comment">//表示一个状态</span></span><br></pre></td></tr></table></figure>
<ol>
<li>使用 <strong>|</strong> 将每一个状态添加到<code>state</code>里面。如1的二进制是0001，2的二进制为0010。包含两个状态的值为0011。</li>
<li>使用 <strong>&amp;</strong> 来判断<code>state</code>是否包含此状态，如1000&amp;0101=1000，因为我们是通过每一位是否包含1来判断是否包含这个状态。所以每一个状态必须满足2^n。<br>我们将枚举的每一个值写作2^n，这样每一个值在二进制下只有一位为1，其余为0。<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="枚举声明如下："><a href="#枚举声明如下：" class="headerlink" title="枚举声明如下："></a>枚举声明如下：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> State&#123;</span><br><span class="line">A=<span class="number">0</span>,</span><br><span class="line">B=<span class="number">1</span>&lt;&lt;<span class="number">0</span>,</span><br><span class="line">C=<span class="number">1</span>&lt;&lt;<span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> State state  =<span class="number">0</span>;<span class="comment">//状态</span></span><br></pre></td></tr></table></figure>
<h4 id="添加状态"><a href="#添加状态" class="headerlink" title="添加状态"></a>添加状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">addState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">this</span>.state | state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="判断是否包含状态"><a href="#判断是否包含状态" class="headerlink" title="判断是否包含状态"></a>判断是否包含状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">includeState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.state &amp; state) == state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除状态"><a href="#删除状态" class="headerlink" title="删除状态"></a>删除状态</h4>删除状态需要先判断一下是否存在此状态。然后通过添加状态的取反就可以将状态删除。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">removeState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = (~state)&amp;<span class="keyword">this</span>.state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://feng-t.github.io/2019/10/17/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E8%A1%A8%E7%A4%BA%E5%A4%9A%E7%A7%8D%E7%8A%B6%E6%80%81/" data-id="ck4b1a6u800006lbkfci121y8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/18/%E7%BA%BF%E7%A8%8B-%E4%B8%89/">线程-三</a>
          </li>
        
          <li>
            <a href="/2019/12/17/%E7%BA%BF%E7%A8%8B-%E4%BA%8C/">线程-二</a>
          </li>
        
          <li>
            <a href="/2019/12/05/%E7%BA%BF%E7%A8%8B-%E4%B8%80/">线程(一)</a>
          </li>
        
          <li>
            <a href="/2019/10/17/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E8%A1%A8%E7%A4%BA%E5%A4%9A%E7%A7%8D%E7%8A%B6%E6%80%81/">使用一个变量表示多种状态</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>