<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>线程-一 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC] 线程基础线程状态线程的状态又分为五种:  New：新建状态 Runnable：就绪状态 Running：运行状态 Blocked：阻塞状态 Dead：死亡状态  1234567graph TDNew --&amp;gt; RunnableRunnable--&amp;gt;RunningBlocked--&amp;gt;RunnableRunning--&amp;gt;RunnableRunning--&amp;gt;Blo">
<meta property="og:type" content="article">
<meta property="og:title" content="线程-一">
<meta property="og:url" content="http:&#x2F;&#x2F;feng-t.github.io&#x2F;2019&#x2F;12&#x2F;05&#x2F;%E7%BA%BF%E7%A8%8B-%E4%B8%80&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC] 线程基础线程状态线程的状态又分为五种:  New：新建状态 Runnable：就绪状态 Running：运行状态 Blocked：阻塞状态 Dead：死亡状态  1234567graph TDNew --&amp;gt; RunnableRunnable--&amp;gt;RunningBlocked--&amp;gt;RunnableRunning--&amp;gt;RunnableRunning--&amp;gt;Blo">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-12-18T08:31:09.524Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://feng-t.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-线程-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/05/%E7%BA%BF%E7%A8%8B-%E4%B8%80/" class="article-date">
  <time datetime="2019-12-05T12:23:15.072Z" itemprop="datePublished">2019-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      线程-一
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>线程的状态又分为五种:</p>
<ul>
<li>New：新建状态</li>
<li>Runnable：就绪状态</li>
<li>Running：运行状态</li>
<li>Blocked：阻塞状态</li>
<li>Dead：死亡状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">New --&gt; Runnable</span><br><span class="line">Runnable--&gt;Running</span><br><span class="line">Blocked--&gt;Runnable</span><br><span class="line">Running--&gt;Runnable</span><br><span class="line">Running--&gt;Blocked</span><br><span class="line">Running--&gt;Dead</span><br></pre></td></tr></table></figure>

<h4 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h4><h5 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h5><p>判断当前线程是否是中断、停止状态，执行后将状态标志清除为<code>false</code>，静态方法。可以直接调用</p>
<h5 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h5><p>判断当前线程是否是中断、停止状态。但不清除状态标志。非静态方法。</p>
<h5 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h5><p>将状态标记为中断，用于线程退出。在<code>run</code>方法中使用<code>interrupted</code>判断线程状态。如果返回<code>true</code>则<code>return</code>或抛出异常。</p>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h5><p>将Running状态转变为Runnable状态。把线程CPU让给其他线程，让出时间不确定，有可能上一秒让出下一秒又获取到。</p>
<h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h5><p>使线程休眠多少毫秒，参数为<code>long</code> ms</p>
<h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><p>join方法的作用是父线程等待子线程执行完成后再执行。换句话说就是将异步执行的线程合并为同步的线程。</p>
<h4 id="wait-notify-notifyAll方法"><a href="#wait-notify-notifyAll方法" class="headerlink" title="wait/notify/notifyAll方法"></a>wait/notify/notifyAll方法</h4><p>这些方法并不是Thread类中的。而是Object类的方法。不过这些也是学习线程中不可或缺的。</p>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h5><p><code>wait()</code>方法的作用是将当前运行的线程挂起（即让其进入阻塞状态），直到notify或notifyAll方法来唤醒线程。此方法需要与锁一起使用。</p>
<h5 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h5><p>与使用<code>wait</code>的同一对象使用该方法即可唤醒处于等待的线程。</p>
<h5 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h5><p>与<code>notify</code>方法差不多，只不过<code>notify</code>只唤醒当前线程。而<code>notifyAll</code>则唤醒所有线程。</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>在线程中可以通过<code>setPriority(int)</code> 来设置线程优先级。子类的优先级与父类的优先级一致。<br>线程优先级从低到高为1~10。超过则抛出<code>IllegalArgumentException()</code>异常<br>且线程优先级不代表一定会按照顺序执行。</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>在Java线程中有两种线程，一种是用户线程，另一种是守护线程。<br>一旦用户线程全都执行完毕之后，守护线程也会结束。没有用户线程时守护进程将自动销毁。<br>线程可以在执行<code>start()</code>方法之前执行<code>setDaemon(true)</code> 变成守护进程。</p>
<h3 id="对象及变量并发访问"><a href="#对象及变量并发访问" class="headerlink" title="对象及变量并发访问"></a>对象及变量并发访问</h3><p>当多个线程对一个对象实例或者一个对象实例变量访问的时候就有可能出现线程安全。</p>
<h4 id="方法内的变量为线程安全"><a href="#方法内的变量为线程安全" class="headerlink" title="方法内的变量为线程安全"></a>方法内的变量为线程安全</h4><p>所有线程内部的私有变量都不会引起线程安全</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p><code>synchronized</code>所声明的方法为线程安全。<br><code>synchronized</code> 使用：<br><code>synchronized</code>可以在方法签名中声明。也可以声明代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mothed</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(Obj)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好不要使用String，或其他基本数据类型作为<code>synchronized</code>所修饰的对象。因为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a1=<span class="string">"aa"</span>;</span><br><span class="line">String a2=<span class="string">"aa"</span>;</span><br></pre></td></tr></table></figure>
<p>由于常量池的原因。a1=a2。所以在<code>synchronized(String)</code>中会被当成同一个对象。<br>使用<code>synchronized</code>之后，异步方法会进行排队。可以看作原子级的方法。<br>只有共享变量/实例才需要同步。如果不是共享变量或实例则不需要同步。</p>
<h5 id="synchronized-重入"><a href="#synchronized-重入" class="headerlink" title="synchronized 重入"></a>synchronized 重入</h5><p>对<code>synchronized</code>声明的代码块，方法来说都具有重入的特性，也就是说<code>synchronized</code>代码块或方法可以调用同一个对象的<code>synchronized</code>而不会产生死锁。</p>
<h5 id="synchronized-同步代码块"><a href="#synchronized-同步代码块" class="headerlink" title="synchronized 同步代码块"></a>synchronized 同步代码块</h5><p>使用<code>synchronized</code>声明一个同步代码块比直接声明一个方法性能要好很多。同时使用一个对象实例比<code>this</code>效率要高一些。使用<code>synchronized(非this)</code>代码块中的程序与其他同步方法是异步的。因为他锁的对象不是this，如果需要同步的话需要锁住的对象是同一个。<br><strong>注意</strong>：同步代码块放在非同步synchronized方法中进行声明，并不能保证调用方法的线程的执行顺序。所以非常容易产生“脏读”的问题。<br>也就是说<code>synchronized</code>修饰方法时，锁住的对象是<code>this</code>。所以<code>synchronized</code>修饰的方法与<code>synchronized(非this)</code>的代码块之间非常容易出问题。</p>
<h5 id="synchronized静态同步"><a href="#synchronized静态同步" class="headerlink" title="synchronized静态同步"></a>synchronized静态同步</h5><p><code>synchronized</code>可以用到静态方法上，这样写是对当前*.java文件对应的Class类进行加锁。<code>synchronized</code>加到静态方法上是对Class加锁。<code>synchronized</code>加到非静态方法上是给对象加锁。如果有一个静态方法。同时有两个实例调用此方法。则该方法为同步方法。<br><code>synchronized(Object.class)</code>等于<code>synchronized</code>声明静态方法。</p>
<h5 id="锁对象改变"><a href="#锁对象改变" class="headerlink" title="锁对象改变"></a>锁对象改变</h5><p>在同步代码块中如果锁对象发生了改变，会发生什么呢？锁对象还有用吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test1 test1 = <span class="keyword">new</span> Test1();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test1.ts(Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                test1.ts(Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lock = <span class="string">"a1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ts</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">":start"</span>);</span><br><span class="line">            lock = <span class="string">"a2"</span>;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(name + <span class="string">":end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真实情况是：一旦锁发生了改变，且在改变之后又有新的线程进来。那么这两个线程的锁对象就不相等。就会变成异步方法。同时可能会产生“脏读”的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A1:start</span><br><span class="line">A2:start</span><br><span class="line">A1:end</span><br><span class="line">A2:end</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong> 只要对象不变。就算对象的属性变了，运行的结果也是同步。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p><code>volatile</code>是为了确保公共堆栈中的变量与线程私有栈中的变量保持一致。使用了<code>volatile</code>之后会从公共堆栈取值。<br><strong>如图所示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        volatileTest test = <span class="keyword">new</span> volatileTest();</span><br><span class="line">        test.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        test.setFlag(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volatileTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入run"</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"退出run：count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程没有及时读到最新的值。那么就可能会出现死循环。</p>
<p>他会一直卡在<code>while</code>循环中。因为在公共堆栈中已经修改了flag的值。但是在线程私有栈中却没有更新<code>flag</code>的值<br>加了<code>volatile</code>之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        volatileTest test = <span class="keyword">new</span> volatileTest();</span><br><span class="line">        test.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        test.setFlag(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volatileTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入run"</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"退出run：count = "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入run</span><br><span class="line">退出run：count = <span class="number">744998007</span></span><br></pre></td></tr></table></figure>
<h5 id="volatile与synchronized"><a href="#volatile与synchronized" class="headerlink" title="volatile与synchronized"></a>volatile与synchronized</h5><p> 乍一看volatile似乎可以解决多线程下的“脏读”问题了。但是其实上并不是。</p>
<ul>
<li><code>volatile</code>是线程同步的轻量级实现。所以<code>volatile</code>的性能比<code>synchronized</code>要好。但是随着JDK版本的提升。<code>synchronized</code>效率也的到了加强。</li>
<li>多线程访问<code>volatile</code>不会发生阻塞。<code>synchronized</code>会发生阻塞。</li>
<li><code>volatile</code>能保证数据可见性。但是不能保证原子性。而<code>synchronized</code>可以保证原子性。也可以间接保证可见性。因为他会将私有内存与公共内存中的数据做同步。</li>
<li><code>volatile</code>解决的是变量在多个线程中的可见性。而<code>synchronized</code>解决的是多个线程之间访问资源的同步性。</li>
<li>线程安全包含原子性和可见性两个方面。Java的同步机制都是围绕这两个方面来确保线程安全的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">new</span> volaitleTest().start();        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volaitleTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count; </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">             count++;   </span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"count:"</span> + count);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有的结果中都没有<code>count=10000</code>的这条结果。这个问题是因为<code>count++</code>并不是一个原子性操作。<br><strong>解决：</strong> 有一点需要注意。也就是<code>count</code>是<code>static</code>所修饰的。而且在<code>main</code>方法中是<code>new</code>了100个线程。所以我们在使用<code>synchronized</code>的时候锁对象一定是一个<code>Class</code>；<br>如将<code>synchronized</code>添加到static方法中。或者<code>synchronized</code>代码块中的锁对象是一个当前类的<code>Class</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> volaitleTest().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volaitleTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (volaitleTest.class) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"count:"</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出虽然顺序是随机的。但是一定有一条数据是count等于10000；<br><strong>方案二</strong> 使用原子类<br>在前面我们使用了<code>synchronized</code>，这次我们不用<code>synchronized</code>而使用原子类。<br>原子类可以将i++这样的操作当成一个原子操作。而不使用锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> volaitleTest().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">volaitleTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (volaitleTest.class) &#123;</span><br><span class="line">                count.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"count:"</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最终结果也有10000。针对与i++这样的操作可以使用原子类来做到线程安全。<br><strong>还有个问题</strong> 虽然最终的结果已经是10000了，但是他不是顺序的。这是因为方法与方法之间不是同步的。将代码稍微改一下：将输出语句添加到同步块中，这样结果就是顺序的了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://feng-t.github.io/2019/12/05/%E7%BA%BF%E7%A8%8B-%E4%B8%80/" data-id="ck4b8s85c0002nobk7h6nchzv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/17/%E7%BA%BF%E7%A8%8B-%E4%BA%8C/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          线程-二
        
      </div>
    </a>
  
  
    <a href="/2019/10/17/%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E8%A1%A8%E7%A4%BA%E5%A4%9A%E7%A7%8D%E7%8A%B6%E6%80%81/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">使用一个变量表示多种状态</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/18/%E7%BA%BF%E7%A8%8B-%E4%BA%94/">线程-五</a>
          </li>
        
          <li>
            <a href="/2019/12/18/%E7%BA%BF%E7%A8%8B-%E5%9B%9B/">线程-四</a>
          </li>
        
          <li>
            <a href="/2019/12/18/%E7%BA%BF%E7%A8%8B-%E4%B8%89/">线程-三</a>
          </li>
        
          <li>
            <a href="/2019/12/17/%E7%BA%BF%E7%A8%8B-%E4%BA%8C/">线程-二</a>
          </li>
        
          <li>
            <a href="/2019/12/05/%E7%BA%BF%E7%A8%8B-%E4%B8%80/">线程-一</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>